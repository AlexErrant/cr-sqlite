sql_statement_list = {
  sql_statement_list ~ ";" ~ sql_statement
  | sql_statement
}

sql_statement = {
  explain? ~ sql_statements
}

// Only support a subset of statements but we likely need to support all so we can reliably lift these out...
// Can't we split on `;` and just take the things we care about?
sql_statements = {
  alter_table
  | create_index
  | create_table
  | drop_index
  | drop_table
  | expr
}

explain = {
  ^"EXPLAIN" ~ (^"QUERY" ~ ^"PLAN")?
}

// https://sqlite.org/lang_createtable.html
create_table = { 
  ^"CREATE" ~ (^"TEMP" | ^"TEMPORARY") ~ ^"TABLE" ~ 
  (^"IF" ~ ^"NOT" ~ ^"EXISTS")? ~
  schema_name? ~ "." ~ table_name ~ ( "AS" ~ create_from_select | create_from_defn) }

WHITESPACE = _{ " " }

alpha = { 'a'..'z' | 'A'..'Z' }
digit = { '0'..'9' }

// todo: names can have " or [
name = @{ ("\""? ~ (alpha | digit)+ ~ "\"") | (alpha | digit)+}

numeric_literal = @{
    "-"?
    ~ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
    ~ ("." ~ ASCII_DIGIT*)?
    ~ (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?
}
string_literal = { "'" ~ char* ~ "'"}
char = { !"\'" ~ ANY }
schema_name = { name }
table_name = { name }
index_name = { name }
column_name = { name }
table_alias = { name }
column_alias = { name }
table_function = { name }
window_name = { name }
collation_name = { name }
base_window_name = { name }
column_name_list = {
  column_name_list ~ ","
  | column_name
}

create_from_defn = { 
  "(" ~ column_def_list ~ table_constraint_list ~ ")" ~ table_options
}

column_def_list = {
  column_def_list ~ "," ~ column_def |
  column_def
}

column_def = {
  column_name ~ type_name? ~ column_constraint*
}

column_constraint = {
  "CONSTRAINT" ~ name ~ column_constraint_def |
  column_constraint_def
}

column_constraint_def = {
  ^"PRIMARY" ~ ^"KEY" ~ (^"ASC" | ^"DESC")? ~ conflict_clause ~ ^"AUTOINCREMENT"?
  | ^"NOT" ~ ^"NULL" ~ conflict_clause
  | ^"UNIQUE" ~ conflict_clause
  | ^"CHECK" ~ "(" ~ expr ~ ")"
  | ^"DEFAULT" ~ ( "(" ~ expr ~ ")" | literal_value | signed_number)
  | ^"COLLATE" ~ collation_name
  | foreign_key_clause
  | ^"GENERATED" ~ ^"ALWAYS" ~ ^"AS" ~ "(" ~ expr ~ ")" ~ (^"STORED" | ^"VIRTUAL")
}

conflict_clause = {
  ^"ON" ~ ^"CONFLICT" ~ conflict_choice
}

conflict_choice = {
  ^"ROLLBACK"
  | ^"ABORT"
  | ^"FAIL"
  | ^"IGNORE"
  | ^"REPLACE"
}

expr = {
  literal_value
  | bind_parameter
  | column_name
  | table_name ~ "." ~ column_name
  | schema_name ~ "." ~ table_name ~ "." ~ column_name
  | unary_operator ~ expr
  | expr ~ binary_operator ~ expr
  | function_name ~ "(" ~ function_args ~ ")" ~ filter_clause? ~ over_clause?
  | "(" ~ expr_list ~ ")"
  | ^"CAST" ~ "(" ~ expr ~ "AS" ~ type_name ~ ")"
  | expr ~ ^"COLLATE" ~ collation_name
  | expr ~ ^"NOT"? ~ (like_expr | glob_regexp_match_expr)
  | expr ~ (^"ISNULL" | ^"NOT" ~ ^"NULL")
  | expr ~ ^"IS" ~ ^"NOT"? ~ (^"DISTINCT" ~ ^"FROM")? ~ expr
  | expr ~ ^"NOT"? ~ ^"BETWEEN" ~ expr ~ ^"AND" ~ expr
  | expr ~ ^"NOT"? ~ ^"IN" ~ ( "(" ~ in_parenthetical ~ ")" | in_table_like )
  | ^"NOT"? ~ ^"EXISTS"? ~ "(" ~ select_statement ~ ")"
  | ^"CASE" ~ expr? ~ (^"WHEN" ~ expr ~ ^"THEN" ~ expr)+ ~ (^"ELSE" ~ expr)? ~ ^"END"
  | raise_function
}

expr_list = {
  expr ~ ","
  | expr
}

in_parenthetical = {
  select_statement
  | expr_list
  | ""
}

in_table_like = {
  table_name
  | table_function ~ "(" ~ expr_list ~ ")"
  | schema_name ~ "." ~ table_name
  | schema_name ~ "." ~ table_function ~ "(" ~ expr_list ~ ")"
}

like_expr = {
  ^"LIKE" ~ expr ~ (^"ESCAPE" ~ expr)?
}
glob_regexp_match_expr = {(^"GLOB" | ^"REGEXP" | ^"MATCH") ~ expr}

filter_clause = {
  ^"FILTER" ~ "(" ~ ^"WHERE" ~ expr ~ ")"
}

over_clause = {
  ^"OVER" ~ (window_name | "(" ~ base_window_name? ~ detailed_over ~ ")")
}

detailed_over = {
  partition_by? ~ order_by? ~ frame_spec?
}

partition_by = {
  ^"PARTITION" ~ ^"BY" ~ expr_list
}

order_by = {
  ^"ORDER" ~ ^"BY" ~ ordering_term_list
}

frame_spec = {
  (^"RANGE" | ^"ROWS" | ^"GROUPS") ~
    (between_frame_spec | ^"UNBOUNDED" ~ ^"PRECEDING" | expr ~ ^"PRECEDING" | ^"CURRENT" ~ ^"ROW") ~
    frame_spec_exclude?
}

frame_spec_exclude = {
  ^"EXCLUDE" ~ ^"NO" ~ ^"OTHERS"
  | ^"EXCLUDE" ~ ^"CURRENT" ~ ^"ROW"
  | ^"EXCLUDE" ~ ^"GROUP"
  | ^"EXCLUDE" ~ ^"TIES"
}

ordering_term = {
  expr ~ (^"COLLATE" ~ collation_name)? ~ (^"ASC" | ^"DESC")? ~ (^"NULLS" ~ ^"FIRST" | ^"NULLS" ~ ^"LAST")?
}

raise_function = {
  ^"RAISE" ~ "(" ~ (^"IGNORE" | ((^"ROLLBACK" | ^"ABORT" | ^"FAIL") ~ "," ~ error_message)) ~ ")"
}

foreign_key_clause = {
  ^"REFERENCES" ~ table_name ~ 
    ( "(" ~ column_name_list ~ ")" )? ~
    fk_clause_on_or_match ~ ^"NOT"? ~ ^"DEFERRABLE" ~ (^"INITIALLY" ~ ^"DEFERRED" | ^"INITIALLY" ~ ^"IMMEDIATE")?  
}

fk_clause_on_or_match = {
  fk_clause_on_or_match ~ fk_clause_on
  | fk_clause_on_or_match ~ fk_clause_match
  | ""
}

fk_clause_on = {
  ^"ON" ~ (^"DELETE" | ^"UPDATE") ~ (
    ^"SET" ~ ^"NULL"
    | ^"SET" ~ ^"DEFAULT"
    | ^"CASCADE"
    | ^"RESTRICT"
    | ^"NO" ~ ^"ACTION"
  )
}

fk_clause_match = {
  ^"MATCH" ~ name
}

literal_value = {
  numeric_literal
  | string_literal
  | blob_literal
  | ^"NULL"
  | ^"TRUE"
  | ^"FALSE"
  | ^"CURRENT_TIME"
  | ^"CURRENT_DATE"
  | ^"CURRENT_TIMESTAMP"
}

signed_number = {
  ("+" | "-")? ~ numeric_literal
}

type_name = {
  name+ ~ ("(" ~ signed_number ~ ")" | "(" ~signed_number ~ "," ~ signed_number ~ ")")
}

select_statement = {
  with_select_statement
  | common_select_statement
}

with_select_statement = {
  ^"WITH" ~ ^"RECURSIVE"? ~ common_table_expression_list ~ common_select_statement
}

common_select_statement = {
  ^"SELECT" ~ (^"DISTINCT" | ^"ALL")? ~ result_column_list ~ 
    select_modifiers ~ (compound_operator | order_by_limit)
  | ^"VALUES" ~ paren_list_of_expr_list ~ (compound_operator | order_by_limit)
}

select_modifiers = {
  select_from
  | select_where
  | select_group_by
  | select_window
}

select_from = {
  ^"FROM" ~ (join_clause | table_or_subquery_list) ~
    (select_where | select_group_by | select_window)?
}

select_where = {
  ^"WHERE" ~ expr ~ (select_group_by | select_window | select_having)?
}

select_group_by = {
  ^"GROUP" ~ ^"BY" ~ expr_list ~ (select_having | select_window)?
}

select_having = {
  ^"HAVING" ~ expr
}

select_window = {
  ^"WINDOW" ~ window_name_as_list
}

window_name_as_list = {
  window_name_as_list ~ "," ~ window_name_as
  | window_name_as
}

window_name_as = {
  window_name ~ ^"AS" ~ window_defn
}

order_by_limit = {
  order_by
  | limit
}

limit = {
  ^"LIMIT" ~ expr ~ (^"OFFSET" ~ expr | "," ~ expr)?
}

common_table_expression_list = {
  common_table_expression_list ~ "," ~ common_table_expression
  | common_table_expression
}

common_table_expression = {
  table_name ~ ("(" ~ column_name_list ~ ")")? ~
    ^"AS" ~ ^"NOT"? ~ ^"MATERIALIZED"? ~ "(" ~ select_statement ~ ")"
}

compound_operator = {
  ^"UNION" ~ ^"ALL"?
  | ^"INTERSECT"
  | ^"EXCEPT"
}

join_clause = {
  table_or_subquery ~ join_sequence
}

join_sequence = {
  join_sequence ~ join_operator ~ table_or_subquery ~ join_constraint
  | ""
}

join_constraint = {
  ^"ON" ~ expr
  | ^"USING" ~ ("(" ~ column_name_list ~ ")")?
  | ""
}

join_operator = {
  ","
  | ^"NATURAL"? ~ lrfi_join? ~ ^"JOIN"
  | ^"CROSS" ~ ^"JOIN"
}

lrfi_join = {
  ^"LEFT" ~ ^"OUTER"?
  | ^"RIGHT" ~ ^"OUTER"?
  | ^"FULL" ~ ^"OUTER"?
  | ^"INNER"
}

result_column = {
  expr ~ (^"AS"? ~ column_alias)?
  | "*"
  | ^"table_name" ~ "." ~ "*"
}

result_column_list = {
  result_column_list ~ "," ~ result_column
  | result_column
}

table_or_subquery = {
  (schema_name ~ ".")?
    ~ (table_for_subquery | table_function_for_subquery)
    ~ (^"AS"? ~ table_alias)?
  | "(" ~ select_statement ~ ")" ~ (^"AS"? ~ table_alias)?
  | "(" ~ table_or_subquery_list ~ ")"
  | "(" ~ join_clause ~ ")"
}

table_or_subquery_list = {
  table_or_subquery_list ~ "," ~ table_or_subquery
  | table_or_subquery
}

table_for_subquery = {
  table_name ~ ^"AS"? ~ table_alias ~ index_hints?
}

index_hints = {
  ^"INDEXED" ~ ^"BY" ~ index_name
  | ^"NOT" ~ ^"INDEXED"
}

table_or_subquery_list = {
  table_or_subquery_list ~ "," ~ table_or_subquery
  | table_or_subquery
}

table_function_for_subquery = {
  table_function ~ "(" ~ expr_list ~ ")"
}

window_defn = {
  "(" ~ base_window_name? ~ partition_order_frame? ~ ")"
}

partition_order_frame = {
  partition_by
  | order_by
  | frame_spec
}

table_constraint = {
  ^"CONSTRAINT" ~ name ~ pucf_constraint
  | pucf_constraint
}

pucf_constraint = {
  ^"PRIMARY" ~ ^"KEY" ~ unique_suffix
  | ^"UNIQUE" ~ unique_suffix
  | ^"CHECK" ~ "(" ~ expr ~ ")"
  | ^"FOREIGN" ~ ^"KEY" ~ "(" ~ indexed_column ~ ")" ~ foreign_key_clause
}

unique_suffix = {
  "(" ~ column_name_list ~ ")" ~ conflict_clause
}

indexed_column = {
  (column_name | expr) ~ (^"COLLATE" ~ collation_name)? ~ (^"ASC" | ^"DESC")?
}

indexed_column_list = {
  indexed_column_list ~ ","
  | indexed_column
}

table_options = {
  table_options ~ "," ~ table_option
  | table_option
}

table_option = {
  ^"WITHOUT" ~ ^"ROWID"
  | ^"STRICT"
}

create_index = {
  ^"CREATE" ~ ^"UNIQUE"? ~ ^"INDEX" ~ if_not_exists? ~
    (schema_name ~ ".")? ~ index_name ~ ^"ON" ~ table_name ~
    "(" ~ indexed_column_list ~ ")" ~
    ^"WHERE" ~ expr
}

if_not_exists = {
  ^"IF" ~ ^"NOT" ~ ^"EXISTS"
}

drop_index = {
  ^"DROP" ~ ^"INDEX" ~ (^"IF" ~ ^"EXISTS")? ~ (schema_name ~ ".")? ~ index_name
}

drop_table = {
  ^"DROP" ~ ^"TABLE" ~ (^"IF" ~ ^"EXISTS")? ~ (schema_name ~ ".")? ~ table_name
}

alter_table = {
  ^"ALTER" ~ ^"TABLE" ~ (schema_name ~ ".")? ~ table_name ~ rrad_table
}

rrad_table = {
  ^"RENAME" ~ ^"TO" ~ table_name
  | ^"RENAME" ~ ^"COLUMN"? ~ column_name ~ ^"TO" ~ column_name
  | ^"ADD" ~ ^"COLUMN"? ~ column_def
  | ^"DROP" ~ ^"COLUMN"? ~ column_name
}